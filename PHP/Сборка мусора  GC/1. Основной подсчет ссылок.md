#gc #garbage_ollection #php
## Основы подсчёта ссылок

Переменная PHP хранится в контейнере `zval` (Zend Value — Zend-значение).
`zval` струткура:
- `type` - тип
- `value` - значение
- `is_ref` - указывает включил ли PHP переменную в «набор ссылок» или нет
- `refcount` - счетчик ссылок
	Кол-во имён переменных, или другое название — символов, которые указывают на этот `zval`-контейнер

За счёт бита `is_ref` PHP-движок знает, как отличать обычные переменные от ссылок. Поскольку PHP разрешает пользовательские ссылки, которые создают оператором `&`, контейнер `zval` также содержит внутренний механизм подсчёта ссылок для оптимизации работы памяти

Каждый символ (_название переменной_) хранится в таблице символов. У каждой области видимости переменных своя таблица символов. PHP создаёт отдельную область видимости для главного скрипта, который срабатывает при запросе из браузера, и отдельную область видимости для каждой функции или метода.

---

Контейнер `zval` создаётся при объявлении новой переменной, которой присваивается константное значение, например:

#### Создание нового контейнера `zval`

```php
$a = "example string";
```

В примере в текущей области видимости создаётся новый символ с именем "`a`" и новый контейнер переменной с типом  `string` и значением `example string`. Бит `is_ref` по умолчанию задаётся равным `false`, поскольку не создали ни одной пользовательской ссылки. Значение же бита `refcount` задаётся равным `1`, поскольку с этим контейнером PHP связал только один символ. Обратите внимание, что ссылки — `zval`-контейнеры с битом `is_ref`, равным `true`, — бит `refcount` которых равен `1`, обрабатываются так, как если бы они не были ссылками (то есть как если бы бит `is_ref` был равен `false`).

---

#### Вывод информации о `zval`-контейнере

Расширение XDebug умеет выводить эту информацию через функцию `xdebug_debug_zval()`.

```php
$a = "example string";  
xdebug_debug_zval('a'); // a: (refcount=1, is_ref=0)='example string'
```

---

#### Увеличение счётчика ссылок контейнера `zval`

Присваивание одной переменной другому имени переменной увеличивает счётчик ссылок.

```php
$a = "example string";
$b = $a;
xdebug_debug_zval('a'); // a: (refcount=2, is_ref=0)='example string'
```

#### Уменьшение счётчика ссылок контейнера `zval`

```php
$a = "example string";
$c = $b = $a;
xdebug_debug_zval('a'); // a: (refcount=3, is_ref=0)='example string'

$b = 42;
xdebug_debug_zval('a'); // a: (refcount=2, is_ref=0)='example string'

unset( $c );
xdebug_debug_zval('a'); // a: (refcount=1, is_ref=0)='example string'
```

Вызов `unset($a)` в этом месте удалит контейнер переменной из памяти, включая тип и значение.

## Составные типы данных

Хранение составных типов данных наподобие массивов `array`и объектов `object` усложняется. Каждый элемент массива или каждое свойство объекта хранится в отдельной таблице символов, в противоположность хранению скалярных `scalar` значений одной и той же области видимости в одной таблице символов. Следующий пример создаст сразу три `zval`-контейнера:

```php
$a = [
	'meaning' => 'life',
	'number' => 42,
];  
xdebug_debug_zval('a');
```

```
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=1, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42
)
```

![[Pasted image 20250114090245.png]]

PHP создаёт три `zval`-контейнера для символов: `a`, `meaning` и `number`. Аналогичные правила применяются для увеличения и уменьшения количества ссылок. В следующем примере в массив добавляется ещё один элемент, которому устанавливается значение другого элемента массива:

```php
$a = [
	'meaning' => 'life',
	'number' => 42,
];
$a['life'] = $a['meaning'];  
xdebug_debug_zval('a');
```

```
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=2, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42,
   'life' => (refcount=2, is_ref=0)='life'
)
```

![[Pasted image 20250114090255.png]]

Из вывода расширения XDebug видно, что как старый, так и новый элемент массива теперь указывает на `zval`-контейнер, значение `refcount` которого равно `2`. Хотя вывод модуля XDebug показывает два zval-контейнера со значением `'life'`, контейнеры одинаковы. Функция `xdebug_debug_zval()` не показывает, что контейнеры одинаковы, но добавление в вывод указателей памяти покажет.

Элемент удаляется из массива аналогично удалению символа из области видимости: счётчик ссылок `refcount` того контейнера, на который указывает элемент массива, уменьшается. Контейнер переменной удаляется из памяти, когда значение в бите `refcount` достигает нуля. Пример:

```php
$a = [
	'meaning' => 'life',
	'number' => 42,
];
$a['life'] = $a['meaning'];  
unset($a['meaning'], $a['number']);  

xdebug_debug_zval('a');
```

```
a: (refcount=1, is_ref=0)=array (
   'life' => (refcount=1, is_ref=0)='life'
)
```

Ситуация станет интереснее, если добавить массив сам в себя. В следующем примере вводится оператор присваивания по ссылке, чтобы PHP не создал копию массива.

```php
$a = ['one'];  
$a[] = &$a;  
xdebug_debug_zval('a');
```

```
a: (refcount=2, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=2, is_ref=1)=...
)
```

![[Pasted image 20250114090307.png]]

Видно, что переменная массива `a`, и второй элемент с индексом `1` теперь указывают на контейнер переменной, значение `refcount` которого равно `2`. Символы «...» в выводе показывают рекурсию, что в этом примере означает, что символы «...» указывают на исходный массив.

Как и раньше, при удалении переменной символ удаляется, а счётчик ссылок контейнера переменной, на который указывает переменная, уменьшается на единицу. Поэтому, если применить конструкцию `unset` к переменной `$a` после запуска приведённого кода, счётчик ссылок контейнера переменной, на который указывают переменная `$a` и элемент массива с индексом `1`, уменьшится на единицу, с 2 до 1:

```php
$a = ['one'];  
$a[] = &$a;
unset($a);
xdebug_debug_zval('a');
```

```
(refcount=1, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=1, is_ref=1)=...
)
```

![[Pasted image 20250114090317.png]]

## Проблемы очистки

Хотя ни в одной области видимости больше нет символа, который указывает на структуру массива, структуру нельзя очистить, поскольку элемент массива с ключом 1 по-прежнему указывает на этот же массив. Поскольку на структуру не указывает внешний символ, пользователю недоступна очистка этой структуры; поэтому пользователь получает утечку памяти. К счастью, PHP очистит эту структуру данных в конце запроса, но до того момента данные будут занимать ценное место в памяти. Такая ситуация часто возникает при реализации алгоритмов синтаксического анализа или других вещей, в которых дочерние элементы указывают на родительские. С ещё большей вероятностью такая же ситуация возникает с объектами, поскольку с объектами язык неявно работает по ссылке.

Не проблема, если такое случается раз или два, но при тысяче или даже миллионе таких случаев утечки памяти уже станут проблемой. Особенно в скриптах, которые работают долго, например, в демонах, в которых запрос не заканчивается, или в крупных наборах модульных тестов. Последний случай вызвал проблемы при запуске модульных тестов для компонента Template библиотеки ez Components. В ряде случаев требовалось больше 2 ГБ памяти, доступа к которой на тестовом сервере не было.