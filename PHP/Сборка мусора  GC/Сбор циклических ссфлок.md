PHP Version < 5.3.0

Механизмы подсчёта ссылок в памяти не справлялись с утечками памяти, которые вызывали циклические ссылки

PHP Version >= 5.3.0

Реализован синхронный алгоритм из исследования [» Concurrent Cycle Collection in Reference Counted Systems](https://pages.cs.wisc.edu/~cymen/misc/interests/Bacon01Concurrent.pdf) (англ. «Параллельный сбор циклических ссылок в системах подсчёта ссылок»), который решает эту проблему.

---

Базовые правила.
1. PHP продолжает хранить в памяти и не рассматривает как мусор контейнеры, значение бита refcount которых увеличилось. `zval`-контейнер, количество ссылок в котором уменьшилось до нуля, освобождается из памяти. Поэтому мусорные циклы — утечки памяти из-за циклических ссылок — появляются только при уменьшении аргумента `refcount` до не нулевого значения.
2. PHP умеет обнаруживать мусорные части в мусорных циклах путём уменьшения количества ссылок в контейнерах на единицу и проверки, в каких `zval`-контейнерах количество ссылок стало нулевым.

TODO переделать на exdriwe схемы
![[Pasted image 20241202154150.png]]

---

Алгоритм помещает возможные корни — `zval`-контейнеры — в «корневой буфер» и помечает корни «фиолетовыми», чтобы не вызывать проверку мусорных циклов при каждом уменьшении счётчика ссылок. Алгоритм следит и за тем, чтобы каждый возможный мусорный корень попадал в буфер только один раз. Механизм сборки мусора для каждого `zval`-контейнера внутри буфера стартует, только когда корневой буфер заполняется. Графически поведение показывает шаг `A` на рисунке выше.

TODO отобразить схему `A`

---

На шаге `B` алгоритм выполняет поиск в глубину по каждому возможному корню, чтобы однократно уменьшить количество ссылок в каждом контейнере на единицу, и помечает корни «серыми».

TODO отобразить схему `B`

---

На шаге `C` алгоритм снова выполняет поиск в глубину от каждого корневого узла, чтобы ещё раз проверить количество ссылок для каждого `zval`-контейнера. Алгоритм помечает корни с нулевым количеством ссылок «белыми» (на рисунке — синим). А если количество ссылок в контейнере больше нуля, начиная с этого корня поиск идёт в глубину с обратным увеличением количества ссылок на единицу и пометкой корней «черными».

TODO отобразить схему `C`

---

На последнем шаге, `D`, алгоритм обходит корневой буфер и удаляет из него корни контейнеров. Алгоритм заодно проверяет, какие `zval`-контейнеры на предыдущем шаге он пометил «белыми». Каждый «белый» `zval`-контейнер освобождается из памяти.

TODO отобразить схему `D`

---

Теперь, когда есть базовое представление о работе алгоритма, вернёмся к тому, как алгоритм интегрируется с PHP. По умолчанию сборщик мусора PHP включён. Параметр [zend.enable_gc](https://www.php.net/manual/ru/info.configuration.php#ini.zend.enable-gc) в файле `php.ini` разрешает отключить сборку мусора.

При включённом сборщике мусора, алгоритм поиска циклических ссылок выполняется после каждого наполнения корневого буфера. Фиксированный размер корневого буфера равняется 10 000 возможных корней, хотя значение изменяется путём изменения значения константы **`GC_THRESHOLD_DEFAULT`** в файле `Zend/zend_gc.c` исходного кода PHP и пересборки PHP. При выключенном сборщике мусора алгоритм поиска циклических ссылок не запускается. Однако в коревой буфер всё равно записываются возможные корни, независимо от активации механизма сборки мусора через параметр конфигурации.

PHP прекратит запись возможных корней, если корневой буфер заполнится при выключенном механизме сборки мусора. Алгоритм не будет анализировать корни, которые не записал в буфер. Поэтому если корни окажутся мусором с циклическими ссылками, они вызовут утечку памяти, поскольку PHP не очистит их.

Причина постоянной записи корней в буфер даже при выключенном механизме сборки мусора состоит в том, что записать корни быстрее, чем каждый раз, когда удаётся найти корень, проверять, включили ли механизм сборки мусора. Однако сам механизм сборки мусора и алгоритм анализа иногда занимают много времени.

Кроме изменения параметра конфигурации [zend.enable_gc](https://www.php.net/manual/ru/info.configuration.php#ini.zend.enable-gc), доступен запуск механизма сборки мусора через вызов функции [gc_enable()](https://www.php.net/manual/ru/function.gc-enable.php) и остановка механизма функцией [gc_disable()](https://www.php.net/manual/ru/function.gc-disable.php). Вызов этих функций даёт тот же эффект, что и включение или выключение механизма в настройках конфигурации. Возможна также принудительная сборка мусорных циклов, даже если корневой буфер ещё не заполнился. Для этого вызывают функцию [gc_collect_cycles()](https://www.php.net/manual/ru/function.gc-collect-cycles.php), которая возвращает количество циклических ссылок, которые собрал алгоритм.

Смысл включения и выключения механизма сборки мусора, а также ручного запуска механизма состоит в чувствительности отдельных частей приложения ко времени, когда автоматический запуск механизма сборки мусора не нужен. Отключение сборщика мусора в конкретных частях приложения создаёт риск утечки памяти, поскольку отдельные корни не поместятся в ограниченный корневой буфер. Поэтому лучше перед вызовом функции [gc_disable()](https://www.php.net/manual/ru/function.gc-disable.php) вызвать функцию [gc_collect_cycles()](https://www.php.net/manual/ru/function.gc-collect-cycles.php), чтобы освободить память, риск потери которой возникает из-за возможных корней, которые алгоритм уже записал в корневой буфер. Это очистит буфер и даст больше места для хранения корней, пока механизм сбора мусорных циклов будет выключен.